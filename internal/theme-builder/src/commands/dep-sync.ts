import { existsSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import { dirname, join, relative } from 'node:path';
import { pathToFileURL } from 'node:url';

import fg from 'fast-glob';
import pc from 'picocolors';

import type { DepSource, PaletteOption, PaletteSpec, ThemeConfig } from '../types';
import { loadConfig, validateConfig } from '../utils/config';
import { sha256 } from '../utils/hash';
import { findWorkspaceGlobs } from '../utils/workspaces';

const CONFIG_BASENAMES = ['jerry-theme.config', 'theme.config'] as const;
const CONFIG_EXTS = ['js', 'cjs', 'mjs'] as const;
type ConfigExt = (typeof CONFIG_EXTS)[number];

export async function depSync(opts: {
  format: ConfigExt; // 출력 포맷
  include: string; // node_modules 스코프 글롭 (예: @jerryshim-ui/*)
  write: boolean;
  lock: boolean;
  dry: boolean;
}) {
  const root = process.cwd();
  console.info(pc.yellow(`\n[jerry-theme] dep-sync: Starting... from ${root}`));

  const { config, path } = await loadConfig(root);
  const files = await findDependencyConfigs(root, opts.include);
  console.info(pc.gray(`[jerry-theme] dep-sync: Found ${files.length} candidate files`));

  let merged: ThemeConfig = { ...config, palettes: [...(config.palettes ?? [])] };
  validateConfig(merged, path);
  const paletteComments = new Map<string, string>();
  const sources: DepSource[] = [];

  for (const f of files) {
    const dir = dirname(f);
    const pkgPath = join(dir, 'package.json');
    const meta = existsSync(pkgPath) ? JSON.parse(await readFile(pkgPath, 'utf-8')) : {};
    const name = meta.name ?? '(unknown)';
    const version = meta.version ?? '0.0.0';
    const raw = await readFile(f, 'utf-8');
    const cfg = await readConfigAny(f);
    const tag = `${name}@${version}`;
    const hash = sha256(raw);

    validateConfig(cfg, f);
    sources.push({ name, version, file: f, rel: `./${relative(root, f)}`, hash });

    const { out, perItemSource } = mergeConfigs(merged, cfg, `${tag} (${relative(root, f)})`);
    merged = out;

    for (const [k, v] of perItemSource) if (v !== 'main') paletteComments.set(k, `from ${v}`);
  }

  const target = join(root, `jerry-theme.config.${opts.format}`);
  const header = [
    `Generated by jerry-theme dep-sync on ${new Date().toISOString()}`,
    `Sources:`,
    ...sources.map((s) => ` - ${s.name}@${s.version} :: ${s.rel} :: ${s.hash}`),
  ];
  const content = writeConfigString(opts.format, merged, header, { palettes: paletteComments });

  console.info(pc.yellow(`\n[jerry-theme] dep-sync: preview -> ${relative(root, target)}\n`));
  console.info(pc.dim(content));

  if (opts.write && !opts.dry) {
    await writeFile(target, content, 'utf-8');
    console.info(pc.green(`✔ wrote ${relative(root, target)}`));
  }

  if (opts.lock) {
    await writeFile(
      join(root, 'jerry-theme.deps.lock.json'),
      `${JSON.stringify({ generatedAt: new Date().toISOString(), sources }, null, 2)}\n`,
      'utf-8',
    );
    console.info(pc.green('✔ wrote jerry-theme.deps.lock.json'));
  }

  console.info(
    pc.cyan('ℹ️ Run `jerry-theme sync` to generate palettes from the merged configuration.'),
  );
}

async function readConfigAny(absPath: string): Promise<any> {
  const mod = await import(pathToFileURL(absPath).href);
  return (mod as any).default ?? (mod as any);
}

async function findDependencyConfigs(root: string, includeGlob: string): Promise<string[]> {
  const exts = CONFIG_EXTS.join(',');
  const patterns: string[] = [];
  // 워크스페이스 내부
  const globs = await findWorkspaceGlobs(root);
  for (const g of globs) {
    for (const base of CONFIG_BASENAMES) {
      patterns.push(`${g}/${base}.{${exts}}`);
    }
  }

  // node_modules 스코프
  for (const base of CONFIG_BASENAMES) {
    patterns.push(`node_modules/${includeGlob}/${base}.{${exts}}`);
  }

  const files = await fg(patterns, { cwd: root, absolute: true, dot: true });
  // 루트 자신의 설정 파일은 제외
  const rootConfigs = new Set(
    CONFIG_BASENAMES.flatMap((b) => CONFIG_EXTS.map((e) => join(root, `${b}.${e}`))),
  );

  return files.filter((f) => !rootConfigs.has(f));
}

/** PaletteOption 병합 규칙: 더 많이 생성하는 쪽 우선 */
function mergePaletteOption(
  main?: PaletteOption,
  incoming?: PaletteOption,
): PaletteOption | undefined {
  if (!main && !incoming) return undefined;

  const a = main;
  const b = incoming;
  // option 합치기
  const pickOption = (
    optA?: PaletteOption['option'],
    optB?: PaletteOption['option'],
  ): PaletteOption['option'] | undefined => {
    if (optA === 'all' || optB === 'all') return 'all';
    if (optA && optB) return optA === optB ? optA : 'all';
    return optA ?? optB;
  };
  const option = pickOption(a?.option, b?.option);
  const p3 = Boolean(a?.p3 || b?.p3) || undefined;
  const theme = Boolean(a?.theme || b?.theme) || undefined;
  const reverseTheme = Boolean(a?.['reverse-theme'] || b?.['reverse-theme']) || undefined;

  if (!option && !p3 && !theme) return undefined;
  const out: PaletteOption = { option: option ?? 'all' } as PaletteOption;
  if (p3) out.p3 = true;
  if (theme) out.theme = true;
  if (reverseTheme) out['reverse-theme'] = true;
  return out;
}

/** 단일 팔레트 병합 */
function mergePalette(main: PaletteSpec, incoming: PaletteSpec) {
  const merged: PaletteSpec = {
    colorName: main.colorName,
    base: mergePaletteOption(main.base, incoming.base),
    alpha: mergePaletteOption(main.alpha, incoming.alpha),
  };
  const changed =
    JSON.stringify(merged.base) !== JSON.stringify(main.base) ||
    JSON.stringify(merged.alpha) !== JSON.stringify(main.alpha);

  return { merged, changed } as const;
}

function mergeConfigs(main: ThemeConfig, incoming: ThemeConfig, sourceTag: string) {
  // 전역 설정은 main 고정 우선
  const out: ThemeConfig = {
    ...main,
    var_prefix: main.var_prefix,
    theme_prefix: main.theme_prefix,
    outputDir: main.outputDir,
    palettes: [...(main.palettes ?? [])],
  };
  const perItemSource = new Map<string, string>();
  const map = new Map<string, any>();

  // main 먼저 채우고 출처는 'main'
  for (const p of main.palettes ?? []) {
    map.set(p.colorName, p);
    perItemSource.set(p.colorName, 'main');
  }

  // incoming 적용: 없으면 추가, 있으면 항목별 병합
  for (const p of incoming.palettes ?? []) {
    const key = String(p.colorName);
    const cur = map.get(key);
    if (!cur) {
      map.set(key, p);
      perItemSource.set(key, `from ${sourceTag}`);
      continue;
    }
    const { merged, changed } = mergePalette(cur, p);
    if (changed) {
      map.set(key, merged);
      perItemSource.set(key, `merged from ${sourceTag}`);
    }
  }

  out.palettes = Array.from(map.values());
  return { out, perItemSource } as const;
}

function writeConfigString(
  format: 'mjs' | 'cjs' | 'js',
  data: ThemeConfig,
  headerLines: string[],
  perItemComments?: { palettes?: Map<string, string> },
): string {
  const header = ['/**', ...headerLines.map((l) => ` * ${l}`), ' */'].join('\n');
  const lines: string[] = [];
  lines.push(header);

  const isCjs = format === 'cjs';
  lines.push(isCjs ? 'module.exports = {' : 'export default {');

  lines.push(` var_prefix: ${JSON.stringify(data.var_prefix ?? 'theme-')},`);
  lines.push(` theme_prefix: ${JSON.stringify(data.theme_prefix ?? '--jerry-')},`);
  lines.push(` outputDir: ${JSON.stringify(data.outputDir ?? 'src/styles')},`);

  lines.push(' palettes: [');
  for (const p of data.palettes ?? []) {
    const cmt = perItemComments?.palettes?.get(p.colorName);
    if (cmt) lines.push(` // ${cmt}`);
    lines.push(` ${JSON.stringify(p)},`);
  }
  lines.push(' ],');

  lines.push('};');
  return `${lines.join('\n')}\n`;
}
