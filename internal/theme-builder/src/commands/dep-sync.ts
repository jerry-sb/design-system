import { existsSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import { dirname, join, relative } from 'node:path';
import { pathToFileURL } from 'node:url';

import fg from 'fast-glob';
import pc from 'picocolors';

import type { ThemeConfig } from '../types';
import { loadConfig } from '../utils/config';
import { sha256 } from '../utils/hash';
import { findWorkspaceGlobs } from '../utils/workspaces';

const CONFIG_BASENAMES = ['jerry-theme.config', 'theme.config'] as const;
const CONFIG_EXTS = ['js', 'cjs', 'mjs'] as const;
type ConfigExt = (typeof CONFIG_EXTS)[number];

export async function depSync(opts: {
  format: ConfigExt; // 출력 포맷
  include: string; // node_modules 스코프 글롭 (예: @jerry-ui/*)
  write: boolean;
  lock: boolean;
  dry: boolean;
}) {
  const root = process.cwd();
  console.log(pc.cyan('[jerry-theme] dep-sync: Starting'));

  const main = await loadConfig(root);
  const files = await findDependencyConfigs(root, opts.include);
  console.log(pc.gray(`[jerry-theme] dep-sync: Found ${files.length} candidate files`));

  let merged: ThemeConfig = { ...main, palettes: [...(main.palettes ?? [])] };
  const paletteComments = new Map<string, string>();
  const sources: DepSource[] = [];

  for (const f of files) {
    const dir = dirname(f);
    const pkgPath = join(dir, 'package.json');
    const meta = existsSync(pkgPath) ? JSON.parse(await readFile(pkgPath, 'utf-8')) : {};
    const name = meta.name ?? '(unknown)';
    const version = meta.version ?? '0.0.0';
    const raw = await readFile(f, 'utf-8');
    const cfg = await readConfigAny(f);
    const tag = `${name}@${version}`;
    const hash = sha256(raw);
    sources.push({ name, version, file: f, rel: `./${relative(root, f)}`, hash });

    const { out, perItemSource } = mergeConfigs(merged, cfg, `${tag} (${relative(root, f)})`);
    merged = out;

    for (const [k, v] of perItemSource) if (v !== 'main') paletteComments.set(k, `from ${v}`);
  }

  const target = join(root, `jerry-theme.config.${opts.format}`);
  const header = [
    `Generated by jerry-theme dep-sync on ${new Date().toISOString()}`,
    `Sources:`,
    ...sources.map((s) => ` - ${s.name}@${s.version} :: ${s.rel} :: ${s.hash}`),
  ];
  const content = writeConfigString(opts.format, merged, header, { palettes: paletteComments });

  console.log(pc.yellow(`\n[jerry-theme] dep-sync: preview -> ${relative(root, target)}\n`));
  console.log(pc.dim(content));

  if (opts.write && !opts.dry) {
    await writeFile(target, content, 'utf-8');
    console.log(pc.green(`✔ wrote ${relative(root, target)}`));
  }
  if (opts.lock) {
    await writeFile(
      join(root, 'jerry-theme.deps.lock.json'),
      `${JSON.stringify({ generatedAt: new Date().toISOString(), sources }, null, 2)}\n`,
      'utf-8',
    );
    console.log(pc.green('✔ wrote jerry-theme.deps.lock.json'));
  }

  console.log(
    pc.cyan('ℹ️ Run `jerry-theme sync` to generate palettes from the merged configuration.'),
  );
}

async function readConfigAny(absPath: string): Promise<any> {
  const mod = await import(pathToFileURL(absPath).href);
  return (mod as any).default ?? (mod as any);
}

type DepSource = { name: string; version: string; file: string; rel: string; hash: string };

async function findDependencyConfigs(root: string, includeGlob: string): Promise<string[]> {
  const exts = CONFIG_EXTS.join(',');
  const patterns: string[] = [];
  // 워크스페이스 내부
  const globs = await findWorkspaceGlobs(root);
  for (const g of globs) {
    for (const base of CONFIG_BASENAMES) {
      patterns.push(`${g}/${base}.{${exts}}`);
    }
  }

  // node_modules 스코프
  for (const base of CONFIG_BASENAMES) {
    patterns.push(`node_modules/${includeGlob}/${base}.{${exts}}`);
  }

  const files = await fg(patterns, { cwd: root, absolute: true, dot: true });
  // 루트 자신의 설정 파일은 제외
  const rootConfigs = new Set(
    CONFIG_BASENAMES.flatMap((b) => CONFIG_EXTS.map((e) => join(root, `${b}.${e}`))),
  );

  return files.filter((f) => !rootConfigs.has(f));
}

function mergeConfigs(main: ThemeConfig, incoming: ThemeConfig, sourceTag: string) {
  const out: ThemeConfig = { ...main };
  if (!out.outputDir && incoming.outputDir) out.outputDir = incoming.outputDir;

  const perItemSource = new Map<string, string>();
  const map = new Map<string, any>();

  for (const p of main.palettes ?? []) {
    map.set(p.colorName, p);
    perItemSource.set(p.colorName, 'main');
  }
  for (const p of incoming.palettes ?? []) {
    if (!map.has(p.colorName)) {
      map.set(p.colorName, p);
      perItemSource.set(p.colorName, sourceTag);
    }
    // 충돌 시 메인 우선. 필요하면 정책 옵션으로 확장 가능.
  }

  out.palettes = Array.from(map.values());
  return { out, perItemSource } as const;
}

function writeConfigString(
  format: 'mjs' | 'cjs' | 'js',
  data: ThemeConfig,
  headerLines: string[],
  perItemComments?: { palettes?: Map<string, string> },
): string {
  const header = ['/**', ...headerLines.map((l) => ` * ${l}`), ' */'].join('\n');
  const lines: string[] = [];
  lines.push(header);

  const isCjs = format === 'cjs';
  lines.push(isCjs ? 'module.exports = {' : 'export default {');

  if (data.outputDir) lines.push(` outputDir: ${JSON.stringify(data.outputDir)},`);

  lines.push(' palettes: [');
  for (const p of data.palettes ?? []) {
    const cmt = perItemComments?.palettes?.get(p.colorName);
    if (cmt) lines.push(` // ${cmt}`);
    lines.push(` ${JSON.stringify(p)},`);
  }
  lines.push(' ],');

  lines.push('};');
  return `${lines.join('\n')}\n`;
}
